后期绑定：

java默认后期绑定，调用方法时，实际调用的代码最后时刻才被确定。编译器确保方法存在并执行类型检查，但此时不知道确切代码。因此可以实现向上转型。
非面向对象编程使用前期绑定，编译器知道具体执行代码绝对地址。
c++默认前期绑定，使用virtual关键字才能实现后期绑定。

单根继承：

所有java类继承Object。c++则不是。

参数化类型（泛型）




对象标识符：

对象的引用。例如：
String s;
这里创建了一个对象标志符s，s为一个引用（没有指定对象，单独存在）。
创建数组对象实际上是创建了一个引用数组，每个引用被自动初始化为null。
也可以创建基本数据类型的数组。

存储位置：

寄存器：java不能直接控制。
堆栈：java对象不存储，对象引用在里面。
堆：所有java对象存储位置。

常量通常直接放在程序代码内部。
基本类型变量不是引用，直接存储值，放在堆栈中。
基本类型包装器类可在堆中创建对象。

java所有数值类型都有正负号
高精度数值类BigDecimal和BigInteger没有对应的基本类型。高精度支持任意精度。



作用域：
作用域由花括号{}决定。决定了内部定义的变量名（引用）的生命周期。
在作用域内创建的非基本对象的生命周期则不取决于作用域。

import:

java.lang自动导入

操作符：

几乎所有操作符只能操作基本类型。但"="，"=="，"!=" 能操作所有对象。String支持"+"和"+="。

字符串转换：

"+"可以执行字符串转换。当a+b中，a为String类型，b非String时，会将b转成String。注意String类型必须在前面。

=号：

等号左边必须是已命名的变量。a=4, 不能4=a。右边必须能生成一个值。

值传递：

基本数值直接传递。传递双方可以继续操作、修改，互不受影响。对象值传递传递的是引用，传递双方会共享一个对象，修改会相互影响。


算数操作：

整数除法/会直接去掉小数位。

一元+号（表示正值）唯一的作用就是将较小类型的操作数提升为int。

对象比较：

"=="、"!="比较的是对象的引用。
Object.equals()默认行为是比较引用！但一些类里面覆盖了此行为（例如Integer）！

逻辑运算符短路：

条件1 && 条件2 && 条件3，如果条件2为false，则条件3不执行。


数值类型描述：

1.1D, 3L, 0.1F
有时候编译器默认类型不对，需要字符显式指定。

三元操作符ifelse

boolean ? v1 : v2

按位操作符：& |  逻辑操作符：&& ||


java文件：编译单元compile unit。每个编译单元内只能有唯一的public类，类名必须和文件名相同。

java解释器根据环境变量classpath找类文件。如果类在一个文件夹下，直接放地址。如果是jar包，地址需要包含jar本身的文件名。classpath中包含"."，解释器就会找当前目录。

private指除了包含此成员的类，其它任何类都无法访问。
protected提供包访问权限。同包类可以访问。
类不可以private或protected，内部类除外。

没有public修饰的类，其static成员如果是public，还是可以被外部访问。

打印时，对象toString()方法可以在对象本身为null时调用，输出null。（存疑，需测试）

子类实例包含了一个基类的子实例。初始化时，基类子实例先被初始化，然后才是子类自己的初始化。

类型转换：
窄化转换：父类转为子类
扩展转换：子类转为父类
java允许把任何基本数据类型转为别的基本数据类型，除了bool类型外。
数值类型转换时值会截尾而不是四舍五入。

java所有数据类型的大小是设计好的，在不同环境下相同。

bool值的能执行运算很有限，只能赋值true或false，并测试真假。不能加减乘除或其他运算。

两个大int值乘法可能溢出！

for(init;bool;step)语句中，三个语句init,bool,step都可以为空。第一次迭代前执行一次init，每次迭代前执行bool判断，迭代后执行step。三个语句都可以经由逗号操作符分隔成子语句的串联。注意java中只有for循环能够使用逗号操作符！（逗号操作符和逗号分隔符不同。逗号分隔符可用于多个参数定义。）

foreach:
可用于任何Iterable对象和数组。

标签：
break和continue只跳出最下层循环。但加上标签后，可跳出多级循环。如:
label1: //不能在后面加语句
for(...){
    for(...){
        ...
        break label1;
    }
}

continue会执行step语句。break则不执行。如果是continue上级标签，则底层step语句不执行。

switch:
只能接受整数值或枚举。除了default外，其余case分支要加break，否则会接着执行下面的case语句。

方法重载：同方法名，不同参数。
两个方法参数分别为父子类，则优先子类。

构造器调构造器时，被调用构造器必须放在方法体最前。

finalize():
垃圾回收器准备好释放对象的存储空间时，会先调用finalize()方法，然后执行垃圾回收。
对象不一定被垃圾回收，只有垃圾回收执行了，finalize()方法才被调用。
java创建的对象都会被垃圾回收，所以需要使用finalize()的情况，很多时候是需要调用“本地方法”时。即java调用非java方法时。
绝对不能直接调用finalize()。此方法是为垃圾回收器调用的。

初始化：
类里定义属性为对象引用时，初始值默认为Null。
属性初始化时存在顺序，要注意向前引用。
属性自动初始化在构造器初始化前发生，即使它们的定义位置夹杂在方法之间。
只有访问类时才进行类加载。静态初始化在类加载的时候执行，只执行一次。最先执行。
静态块和静态属性类似，只执行一次。
java中同样可以有非静态块。在构造器前，属性自动初始化后执行。

数组：
int[] a;
int a[];两种格式都可以。
只有初始化时，可以使用表达式{}。如int[] a =
{1,2,3};表达式必须和定义类型int[]一起使用。new int[5]类似。但new
int[]{1,2}能在任何情况下使用。
数组传递是引用传递。
非基本类型对象数组是一个引用数组。
基本类型数组new了后会自动初始化。

可变参数列表：
如果传的本身是数组，则直接使用数组。
如果传的是一组值，则先将值拼装成数组。
可以不传值。此时生成一个长度为0的数组，而不是null。
可变参数可以和一般参数混合使用。但似乎只能放最后。
可变单数重载可能造成问题，需要注意。尤其在参数可为空的现状下。

final:
final对象指引用不变，对象内部可变。
必须在定义处或每个构造器给final属性赋值。
数组也是对象，final表示引用不变。

多态
和“动态绑定”、“后期绑定”、“运行时绑定”同义
多态只作用于方法，域不是多态。

绑定
方法调用和实际方法体的关联。在程序执行前绑定成为前期绑定，C只有前期绑定。java的static方法和final方法（private方法都是final）前期绑定，其它后期绑定。

非private方法才能覆盖。子类同名方法被认为是新成员。

类加载在访问类static成员时发生。构造器其实是隐性的静态成员。（但是构造器可以调用非静态属性和方法。）

复杂对象初始化顺序：
1. 调用基类构造器
2. 按声明顺序初始化属性
3. 调用导出类构造器主体

继承清理方法后，清理方法内记得调用父类的清理方法，否则父类不被清理。

构造器中调用覆盖方法可能会造成错误。基类构造时直接调用了子类的覆盖方法！

协变返回类型
覆盖方法的返回类可以为基方法返回类的子类。

接口中的域是隐性static、final的，方法都是隐性public的，不需要public关键字。



# 并发 #
java没有使用进程，而是使用基于顺序编程的线程来实现并发。这是为了OS透明性。有些OS不支持多进程。

java主线程中不会引用创建的分线程。每个线程“引用”自身，所以不会被垃圾回收，除非线程停止。
Thread中执行的Task中抛出的异常不会传播到main，因此需要每个Task主动catch、处理异常。
sleep()会抛出InterruptedException。在sleep时，scheduler会切换线程。
setPiority()要放在run()里面，否则当前进程不对。

daemon thread:
    只要有一个非daemon线程在运行，daemon threads就不会终止。但只要所有非daemon threads完成，daemon threads就会终止。    线程为daemon时，它创建的新线程也为daemon。
    daemon线程不会执行finally clause！！！

不要在构造器中start()。因为对象构造还未完成，线程可能访问不稳定的对象。

join():
    在一个线程中可以call另一个线程t的t.join()。此时caller线程会suspend，并等待线程t执行完再执行。
    join()里可以传递时间参数，待时间完后不管t是否执行完，都返回。
    t.interrupt()可以打断join()。因此join()需要try-catch块。

主线程中不能catch子线程中抛出的异常，需要用到Thread.UncaughtExceptionHandler。

线程之间不应互相依赖，因为无法保证线程之间的顺序以及线程仍然有效（没有异常抛出或停止）。

++、--等自我递增、递减操作是非原子操作！！！因此可能发生并发问题。

mutex：互斥锁

synchronized：一旦一个object的一个synchronized方法被调用，那么所有其它此object的synchronized方法都不能访问。任何对象都存在一个简单锁。

synchronized static方法对class有一个锁。因此能避免线程冲突。

注意：锁住的对象的非synchronized方法仍然能访问。

显式lock：
lock.unlock()必须在try-catch语句的finally clause中，否则可能无法释放。
方法必须在try块里返回，否则unlock先于return执行，存在暴露资源的风险。
显式lock更灵活，能够多次尝试获取Lock，设置获取lock失败后的处置，等等，这样能缓解synchronized方法带来的阻塞。通过finally clause，能够让程序在方法异常后整理状态。

word-tearing：对于“简单操作”和大部分主类型来说，是原子操作。但是，在读写long和double类型数据时，JVM有可能分两次操作（64bit分成两个32bit）。用volatile关键字定义变量（JSE5前不正确）后可避免这一点，实现原子操作（注意是原子操作，不是线程安全）。

原子操作不一定是线程安全的。

多核系统中，visibility很关键。一个核中的某任务的操作，即使是原子性的，也未必被其它核可见，因为有可能存储在单核的缓存中。但同步机制强制操作结果在应用范围内可见。volatile关键字也可保证可视性，即使存在本地cache。它强制属性读写发生在主memory。

如果有多个任务对一个field直接访问，那么需要volatile关键词，否则只需要synchronized保护即可。任务本身的操作对任务必然可见，所以如果只有一个任务直接访问field，那么不需要volatile关键词。

volatile在field的值取决于之前的值时失效（例如++，--等递增、递减操作）。当field的值被其它field约束时也失效。典型的应用volatile关键词的场景是类只存在一个可变field时。

volatile禁止field被缓存，读写直接发生在主memory，同时禁止compiler优化访问顺序。但它不能保证原子性。当多个任务（此处的任务自然指线程任务）能够直接访问field，并至少有一个任务要写时，需要用到volatile。

synchronized块：
能使用synchronized块。隐式块需要一个对象的锁，显式块直接调用ReentrantLock对象。

使用Threadlocal可以使不同线程访问同一个变量的不同储存。每个线程都会获得一个此变量的local储存。

线程四状态：新建、可执行、阻塞、死亡。
阻塞原因：
    sleep();
    wait();
    等待I/O执行完毕
    线程等待获取锁。（想执行synchronized方法但被锁住）
在阻塞过程中打断，可用interrupt方法。此时会抛出InterruptedException。
interrupt方法被调用时，如果线程处于阻塞状态，会抛出InterruptedException，否则不抛出。如果线程当时不在阻塞状态，继续往下执行，直到等它执行到阻塞块时，就会抛出异常。否则会正常执行下去。
Executor对象的shutdownNow()方法可以cancel所有它执行的线程。如果只想cancel一个线程，需要用submit()返回一个Future对象。调Future对象的cancel()方法来cancel。

IO和synchronized阻塞是无法打断的。一个本办法是在发送打断时同时关闭IO资源，可以避免阻塞。此时需要注意的是，线程不一定会处于“打断”状态。例如，Socket会处于打断状态，而System.in则会处于停止，isInterrupted()为false。
nio类则可以直接打断，不需要关闭IO资源。

同一个线程可以调用锁对象的多个不同的同步方法，不需要等锁释放。

任务被ReentrantLock阻塞时可以打断。（JSE5新特性。）打断后ReentrantLock的lockInterruptibly()方法会抛出InterruptedException异常。需要用lockInterruptibly()方法。

thread.interrupt()只在thread处于阻塞时有效。thread不在阻塞状态时，interrupt()无效。interrupt()会设置interrupted状态。通过调用interrupted()方法，不仅能检查interrupted状态，而且会清除此状态。

检查Interrupted状态的通常做法：
try{
    while(!Thread.interrupted()){ // Thread.interrupted()方法判断thread是否处于打断状态。
        try{
            create object!
        }finally{   //在此处需要finally clause，用来清理对象。注意没有catch clause！
            cleanup objects!
        }
    }
}catch(InterruptedException ex){
}finally{
}

busy waiting: idle循环检查状态，导致cpu空转。
sleep()和yield()不会释放对象锁。wait()会。wait()、notify()方法只能在synchronized方法或块中使用。否则运行时会抛异常。
        while (waxOn == false)
            wait();
通常需要使用while来判断标志位，使得wait()方法发生在正确的状态。也就是说，每次通过notify()苏醒时，任务不应该马上执行，而是需要判断是否处于正确的状态，有正确的理由执行下一步。如果不是，则需要继续wait()直到正确的理由成立。因此，需要while语句来进行判断，是否可以执行下一步。

可能出错：
while(condition){
    //point 1
    synchronized(obj){
        obj.wait();
    }
}
因为while语句没有被synchronized，point 1时线程可能会切换到另一个线程。此时另一个线程发出notify()，导致notify在wait前发送，被忽略。从而无限循环下去。正确做法：
synchronized(obj){
    while(condition)
        obj.wait();
}
