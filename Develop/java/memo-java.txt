后期绑定：

java默认后期绑定，调用方法时，实际调用的代码最后时刻才被确定。编译器确保方法存在并执行类型检查，但此时不知道确切代码。因此可以实现向上转型。
非面向对象编程使用前期绑定，编译器知道具体执行代码绝对地址。
c++默认前期绑定，使用virtual关键字才能实现后期绑定。

单根继承：

所有java类继承Object。c++则不是。

参数化类型（泛型）




对象标识符：

对象的引用。例如：
String s;
这里创建了一个对象标志符s，s为一个引用（没有指定对象，单独存在）。
创建数组对象实际上是创建了一个引用数组，每个引用被自动初始化为null。
也可以创建基本数据类型的数组。

存储位置：

寄存器：java不能直接控制。
堆栈：java对象不存储，对象引用在里面。
堆：所有java对象存储位置。

常量通常直接放在程序代码内部。
基本类型变量不是引用，直接存储值，放在堆栈中。
基本类型包装器类可在堆中创建对象。

java所有数值类型都有正负号
高精度数值类BigDecimal和BigInteger没有对应的基本类型。高精度支持任意精度。



作用域：
作用域由花括号{}决定。决定了内部定义的变量名（引用）的生命周期。
在作用域内创建的非基本对象的生命周期则不取决于作用域。

import:

java.lang自动导入

类型转换：
窄化转换：父类转为子类
扩展转换：子类转为父类
java允许把任何基本数据类型转为别的基本数据类型，除了bool类型外。
数值类型转换时值会截尾而不是四舍五入。

java所有数据类型的大小是设计好的，在不同环境下相同。

bool值的能执行运算很有限，只能赋值true或false，并测试真假。不能加减乘除或其他运算。

两个大int值乘法可能溢出！

for(init;bool;step)语句中，三个语句init,bool,step都可以为空。第一次迭代前执行一次init，每次迭代前执行bool判断，迭代后执行step。三个语句都可以经由逗号操作符分隔成子语句的串联。注意java中只有for循环能够使用逗号操作符！（逗号操作符和逗号分隔符不同。逗号分隔符可用于多个参数定义。）

foreach:
可用于任何Iterable对象和数组。

标签：
break和continue只跳出最下层循环。但加上标签后，可跳出多级循环。如:
label1: //不能在后面加语句
for(...){
    for(...){
        ...
        break label1;
    }
}

continue会执行step语句。break则不执行。如果是continue上级标签，则底层step语句不执行。

switch:
只能接受整数值或枚举。除了default外，其余case分支要加break，否则会接着执行下面的case语句。

方法重载：同方法名，不同参数。
两个方法参数分别为父子类，则优先子类。

构造器调构造器时，被调用构造器必须放在方法体最前。

finalize():
垃圾回收器准备好释放对象的存储空间时，会先调用finalize()方法，然后执行垃圾回收。
对象不一定被垃圾回收，只有垃圾回收执行了，finalize()方法才被调用。
java创建的对象都会被垃圾回收，所以需要使用finalize()的情况，很多时候是需要调用“本地方法”时。即java调用非java方法时。
绝对不能直接调用finalize()。此方法是为垃圾回收器调用的。

初始化：
类里定义属性为对象引用时，初始值默认为Null。
属性初始化时存在顺序，要注意向前引用。
属性自动初始化在构造器初始化前发生，即使它们的定义位置夹杂在方法之间。
只有访问类时才进行类加载。静态初始化在类加载的时候执行，只执行一次。最先执行。
静态块和静态属性类似，只执行一次。
java中同样可以有非静态块。在构造器前，属性自动初始化后执行。

数组：
int[] a;
int a[];两种格式都可以。
只有初始化时，可以使用表达式{}。如int[] a =
{1,2,3};表达式必须和定义类型int[]一起使用。new int[5]类似。但new
int[]{1,2}能在任何情况下使用。
数组传递是引用传递。
非基本类型对象数组是一个引用数组。
基本类型数组new了后会自动初始化。

可变参数列表：
如果传的本身是数组，则直接使用数组。
如果传的是一组值，则先将值拼装成数组。
可以不传值。此时生成一个长度为0的数组，而不是null。
可变参数可以和一般参数混合使用。但似乎只能放最后。
可变单数重载可能造成问题，需要注意。尤其在参数可为空的现状下。
