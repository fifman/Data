内存：
    程序计数器: 字节码行号示器
    虚拟机栈: 线程私有，生命周期和线程相同，储存栈帧（stack frame）
    本地方法栈: 和虚拟机栈类似，但为native方法服务。有些虚拟机实现直接将其与虚拟机栈合一。 
    方法区（非堆、Non-Heap）: 线程共享，存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。垃圾回收少。
    堆（GC堆、Garbage Collected Heap）: 线程共享，存放对象（数组）实例。一般来说所有对象存在堆上。根据垃圾回收算法不同可能有不同内部划分。垃圾回收主要点。


内存分配：
    程序计数器：
        不同线程有不同的程序计数器，互不影响
    虚拟机栈：
        栈帧：
            每个java方法执行时创建栈帧并推入虚拟机栈，执行完栈帧出栈。
            存储局部变量表、操作数栈、动态链接、方法出口等信息。
            局部变量表：存储基本数据类型、对象引用、returnAddress类型
    方法区：
        运行时常量池：
            方法区的一部分，存储类文件的常量池（字面量、符号引用）
            具备动态性，不仅编译时，执行时的常量也可放入。
    直接内存（Direct Memory）：
        NIO机制通过native函数直接分配堆外内存。

对象创建：
    指针碰撞（Bump the pointer）: 内存齐整，指针直接挪移一块内存分配给创建对象。
    空闲列表（Free List）: 内存不齐整，需要从可用内存块列表中划分足够大区间给对象。
    Java堆是否齐整由垃圾算法是否带有压缩整理功能决定。
    线程不安全：
        同步处理：CAS加失败重试
        本地线程分配缓冲（Thread Local Allocation Buffer/TLAB）：不同线程划分不同内存空间分配。TLAB用完时，同步。
    流程：
        内存分配
        虚拟机将分配好的内存空间初始化零值。保证了实例字段有初始值。
        然后设置对象头
        调用<init>方法

对象内存中组成结构：
    对象头（Header）
        自身的运行时数据（Mark Word）：哈希码、GC分代年龄、锁状态标识等
        类型指针（不是所有虚拟机都必须保存此项）
        如果是数组，需要存储数组长度
    实例数据(Instance Data)
    对齐填充(Padding)

对象访问方式：
    句柄访问：在堆中分出句柄池，句柄包含对象实例地址和对象类型地址
    直接指针访问：直接访问对象实例，对象实例必须能访问对象类型信息。

内存异常：
    内存溢出（overflow）:程序需要创建多于内存的对象量
    内存泄漏（Leak）:对象存在引用，无法被垃圾回收
    如果多线程导致overflow，则需要减少每个线程的内存分配量

（待补，内存异常判断、纠错）

=垃圾回收=

引用计数算法：对象被引用+1，引用失效时-1。
可达性分析算法（Reachability Analysis）：分析从一系列GC Roots通过引用链（Reference Chain）是否可达对象。
    GC Roots: 
        虚拟机栈中（栈帧中的本地变量表）引用的对象
        方法区中类静态属性引用的变量
        方法区中常量引用的变量
        本地方法栈中JNI（即Native方法）引用的对象
    引用：
        强引用：一直保留在内存
        软引用：内存快溢出时回收
        弱引用：下一次垃圾回收时回收
        虚引用：对对象的生命周期不起作用，唯一作用在于对象被回收时能够通知系统（回调）
    finalize:
        对象的finalize()方法只会被执行一次。如果对象没有成功回收，则下一次finalize()不执行。
        不要使用finalize()方法。
    判断无用类：
        该类所有实例已回收
        加载该类的ClassLoader已被回收。
        该类对应的Class对象没有被引用，无法通过反射访问该类的方法。

标记-清除(Mark Sweep)算法：标记对象然后回收
复制（Copying）算法：1块Eden空间+2块Survivor空间。每次使用1Eden+1Survivor。垃圾回收时对象复制到另一块Survivor。
    如果survivor不够大，由其它内存进行分配担保。
    用于删除新生代
标记-整理算法：
    用于删除老年代
    和标记-清除类似，但清除时所有对象向内存的一端移动。
分代收集策略（Generational Collection）：新生代和老年代用不同垃圾回收算法。

准确式内存管理（Exact VM）:能够分辨内存中的数值是什么类型（是主类型还是引用），因此可以不使用句柄管理对象。

GC停顿：可达性分析必须确保分析过程中引用关系不变，因此必须停顿所有执行线程。
safepoint：准确式内存管理在OoMap中记录了引用位置。在线程执行时，并不是每条指令都会记录一次OoMap，因为开销太大。而是使用了safepoint，在safepoint时才记录。只有safepoint时，才能进行GC。

GC时必须让所有线程都到达safepoint。
    主动式中断（Voluntary Suspension）:GC设置标识。线程在到达safepoint时轮询标识，判断是否需要中断。
线程如果处于阻塞或睡眠，则无法到达safepoint。此时需要safe region（安全区域）。
    安全区域：一片代码片段中，引用关系不会变。
    线程进入和离开安全区域代码片段时，设置和取消安全标识。

收集器：
    新生代：
        serial：单线程，停顿所有工作线程。单CPU时效率高。适合client模式的JVM。
        Parnew：除多线程外，大部分和serial相似。适合server模式。
        Parallel Scavenge: 控制吞吐量
            吞吐量 = 用户代码执行时间/（用户代码执行时间+垃圾回收执行时间）
    老年代：
        Serial Old: 单线程，标记-整理，更适合client模式
        Parallel Old: 多线程，标记-整理，更适合server
        CMS（Concurrent Mark Sweep）:
            初始标记CMS initial mark: 标记GC Roots能够直接引用的对象
            并发标记CMS concurrent mark: 引用跟踪
            重新标记CMS remark: 修正并发标记阶段用户程序运行导致的引用变动
            并发清除CMS concurrent sweep: 清除标记对象

            初始标记、重新标记需要stop the world
            CMS对CPU资源很敏感，需要多CPU（>=4）才比较有效。数量少时会降低速度
            无法处理浮动垃圾（用户程序线程并行运行时产生的新垃圾，不会被标记）
        
垃圾回收同步：
    并发：用户线程和垃圾回收线程都在运行
    并行：垃圾回收多线程，用户线程在等待

GC日志：
    
回收类型：
    Minor GC(新生代GC)
    Major GC(老年代GC)

对象分配：
    优先分配在新生代Eden区
    大对象直接进入老年代
    长期存活对象进入老年代
        年龄：经过一次Minor GC +1
        经过第一次Minor GC后存活，则移入Survivor区
        年龄到一定程度进入老年代
            阈值MaxTenuringThreshold
            动态年龄判定：相同年龄对象总和大于Survivor空间一半，一起进入老年代
    空间分配担保：
        老年代最大可用连续空间>新生代所有对象总空间
            安全, Minor GC
        否则
            HandlePromotionFailure是否允许担保失败
                老年代最大可用连续空间>历次晋升老年代对象平均大小
                    进行Minor GC
                否则
                    Full GC
            否则
                Full GC

虚拟机性能监控

                
    
